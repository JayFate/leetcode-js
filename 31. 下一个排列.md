**中等**

整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。

- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`

解析：

例如 2, 6, 3, 5, 4, 1 这个排列， 我们想要找到下一个刚好比他大的排列，于是可以从后往前看。

我们先看后两位 4, 1 能否组成更大的排列，答案是不可以，同理 5, 4, 1 从右往左也是递增的，也不可以组成更大的排列。

直到 3, 5, 4, 1 这个排列，因为 3 < 5，我们可以通过重新排列这一段数字，来得到下一个排列。

因为我们需要使得新的排列尽量小，所以我们从后往前找第一个比 3 更大的数字，发现是 4。

然后，我们调换 3 和 4 的位置，得到 4, 5, 3, 1 这个数列。

因为我们需要使得新生成的数列尽量小，而且原来的 3, 5, 4, 1 是以 3 为开头的最大的排序，所以下一个刚好比它大的排列必然以 4 开头，于是我们只需要对5, 3, 1进行排序。

可以发现在这个算法中，我们得到的末尾数字一定是倒序排列的，于是我们只需要把它反转即可。最终，我们得到了4, 1, 3, 5 这个数列 完整的数列则是2, 6, 4, 1, 3, 5

总结一下步骤就是:

- 从右往左依次遍历，
- 如果找到第一个比它右边小的数 `nums[i]`  (找拐点)
  - 再从右往左依次遍历，找到第一个比  `nums[i]` 小的数 `nums[j]`
  - 交换  `nums[i]` 和  `nums[j]`的值
  - 交换后，将  `nums[i + 1]` 到  `nums[nums.length - 1]` 直接 reverse 一遍
- 如果找不到，说明  nums 是从大到小排序的，则将 nums 直接 reverse 一遍

```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function (nums) {
  // 1,2,3,8,5,7,6,4
  // 交换后
  // 1,2,3,8,6,7,5,4
  const swap = (i, j) => {
    [nums[i], nums[j]] = [nums[j], nums[i]];
  };
  for (let i = nums.length - 2; i >= 0; i--) {
    // 找拐点
    if (nums[i] < nums[i + 1]) {
      for (let j = nums.length - 1; j > i; j--) {
        if (nums[j] > nums[i]) {
          swap(i, j);
          break;
        }
      }
      // 因为拐点之后的数组，必定是从左到右降序的
      // 所以可以对拐点之后的数组，进行一个双指针换位
      let start = i + 1,
        end = nums.length - 1;
      while (start < end) {
        swap(start, end);
        start++;
        end--;
      }
      // 直接结束函数即可
      return;
    }
  }
  // 如果找不到，说明  nums 是从大到小排序的，则将 nums 直接 reverse 一遍
  nums.sort((a, b) => a - b);
  return;
};
```

